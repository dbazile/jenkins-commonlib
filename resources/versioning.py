#!/usr/bin/env python

from __future__ import print_function

import argparse
import os
import re
import subprocess


DEFAULT_BRANCH        = 'master'
DEFAULT_README_FILE   = 'README.md'
DEFAULT_GRADLE_FILE   = 'build.gradle'

PATTERN_VERSION       = re.compile(r'^(?P<major>\d+)\.(?P<minor>\d+)\.(?P<patch>\d+)*(?:-(?P<qualifier>ALPHA|BETA|RC\d+|SNAPSHOT))?$')
PATTERN_RC            = re.compile(r'^RC(\d+)$')
QUALIFIER_RC          = 'RC'
QUALIFIER_DEV         = 'SNAPSHOT'
INFO_BLOCK_BEGIN      = ' autogenerated release information begin '
INFO_BLOCK_END        = ' autogenerated release information end '
TEMPLATE_TAG          = 'releases/v{version}'
TEMPLATE_MESSAGE_PRE  = '[pre-release] {version}'
TEMPLATE_MESSAGE_POST = '[post-release] {version}'

TEMPLATE_INFO_BLOCK = '''
*----{info_block_begin:-^70}----*

|          |                                                                   |
|----------|-------------------------------------------------------------------|
| Group    | {group:<65} |
| Artifact | {artifact:<65} |
| Version  | {version:<65} |
| Date     | {timestamp:<65} |

*----{info_block_end:-^70}----*
'''


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--branch-dev',     default=DEFAULT_BRANCH,      help='override the default dev branch (' + DEFAULT_BRANCH + ')')
    parser.add_argument('--branch-release', default=DEFAULT_BRANCH,      help='override the default release branch (' + DEFAULT_BRANCH + ')')
    parser.add_argument('--gradle-file',    default=DEFAULT_GRADLE_FILE, help='override the default gradle file (' + DEFAULT_GRADLE_FILE + ')')
    parser.add_argument('--readme-file',    default=DEFAULT_README_FILE, help='override the default README file (' + DEFAULT_README_FILE + ')')
    pg = parser.add_mutually_exclusive_group()
    pg.add_argument('--next-version',   default='',          help='override the next dev version (will be suffixed with -' + QUALIFIER_DEV + ' if necessary)')
    pg.add_argument('--rc',             action='store_true', help='enables release candidate semantics (adds or increments "-RCn" suffix)')

    # Collect params
    options          = parser.parse_args()
    branch_dev       = options.branch_dev
    branch_release   = options.branch_release
    gradle_file      = options.gradle_file
    readme_file      = options.readme_file
    is_rc            = options.rc
    next_version     = options.next_version

    print_bold('PRERELEASE -- STARTED')

    #
    # Validate Git state
    #

    print_green('Checking Git state')
    ensure_clean_working_copy()
    do_checkout(branch_dev)

    #
    # Collect release info
    #

    print_green('Collecting release info')
    group, artifact, current_version = get_artifact_info()
    release_version = to_release_version(current_version, is_rc)
    next_version = normalize_next_version(next_version)
    if not next_version:
        next_version = to_next_version(release_version)

    print_yellow('==> current_version: {}', current_version)
    print_yellow('==> release_version: {}', release_version)
    print_yellow('==>    next_version: {}', next_version)

    #
    # Update README
    #

    print_green("Updating release info block in '{}'", readme_file)
    update_readme(readme_file, group, artifact, release_version)

    #
    # Update Gradle buildscript
    #

    print_green("Updating to release version in '{}'", gradle_file)
    update_gradlefile(gradle_file, release_version)

    #
    # Commit and tag
    #

    print_green("Committing to '{}'", branch_dev)
    do_commit(release_version)
    do_tag(release_version)

    if not is_rc:
        print_bold('RELEASE -- STARTED')

        #
        # Merge to release branch if needed
        #

        if branch_dev != branch_release:
            print_green("Merging to '{}'", branch_release)
            do_merge(branch_dev, branch_release)

        #
        # Apply the next dev version
        #

        print_bold('POSTRELEASE -- STARTED')

        print_green("Updating to next dev version in '{}'", gradle_file)
        do_checkout(branch_dev)
        update_gradlefile(gradle_file, next_version)

        print_green("Committing to '{}'", branch_dev)
        do_commit(release_version, is_post=True)

    print_bold('COMPLETE')

    print_yellow('all thats left to do is to push')


def do_checkout(branch):
    print_dim("==> checking out '{}'", branch)
    try:
        execute(['git', 'checkout', branch])
    except subprocess.CalledProcessError as err:
        fatal_error("could not check out branch '{}'", branch, cmd=err.cmd, output=err.output)


def do_commit(version, is_post=False):
    if is_post:
        message = TEMPLATE_MESSAGE_POST.format(version=version)
    else:
        message = TEMPLATE_MESSAGE_PRE.format(version=version)
    try:
        execute_verbose(['git', 'commit', '-m', message])
    except subprocess.CalledProcessError as err:
        fatal_error('could not commit release', cmd=err.cmd, output=err.output)


def do_merge(branch_dev, branch_release):
    do_checkout(branch_release)
    try:
        execute_verbose(['git', 'merge', branch_dev])
    except subprocess.CalledProcessError as err:
        fatal_error('could not merge branches',
                    dev=branch_dev,
                    release=branch_release,
                    cmd=err.cmd,
                    output=err.output)


def do_tag(version):
    tag = TEMPLATE_TAG.format(version=version)

    print_dim("==> tagging release as '{}'".format(tag))
    try:
        execute_verbose(['git', 'fetch', '--tags'])
        execute_verbose(['git', 'tag', tag])
    except subprocess.CalledProcessError as err:
        fatal_error('could not fetch/create tags', cmd=err.cmd, output=err.output)


def ensure_clean_working_copy():
    try:
        modified_files = execute(['git', 'status', '--short'])
        if modified_files:
            fatal_error('cannot proceed with uncommitted changes', files=modified_files)
    except subprocess.CalledProcessError as err:
        fatal_error('could not check for uncommitted changes', cmd=err.cmd, output=err.output)


def execute(*args, **kwargs):
    """
    :rtype: str
    """
    return subprocess.check_output(*args,
                                   stderr=subprocess.STDOUT,
                                   universal_newlines=True,
                                   **kwargs)


def execute_verbose(*args, **kwargs):
    output = execute(*args, **kwargs).strip()

    if output:
        for line in output.splitlines():
            print_dim('    ' + line)

    return output


def fatal_error(message, *args, **extras):
    print_red('error: {}', message.format(*args))

    if extras:
        for k, v in sorted(extras.items()):
            if isinstance(v, str) and '\n' in v:
                print_dim('{} = (multiline)\n---\n{}\n---', k, v)
                continue
            print_dim('{} = {}', k, repr(v))
    exit(1)


def get_artifact_info():
    """
    :rtype: str, str, str

    Note, to get this info from Maven try `mvn help:evaluate <<< '${project.groupId}:${project.artifactId}:${project.version}' | grep -v '^\['`
    """
    gradle_props = {}
    for line in execute(['gradle', 'properties', '-q']).splitlines():
        if ':' not in line:
            continue
        key, value = line.split(':', 1)
        gradle_props[key.strip()] = value.strip()

    artifact = gradle_props.get('name')
    if not artifact:
        fatal_error("gradle properties missing 'name'")

    group = gradle_props.get('group')
    if not group:
        fatal_error("gradle properties missing 'group'", group=group)

    version = gradle_props.get('version')
    if not version or version == 'unspecified':
        fatal_error("gradle properties missing 'version'", version=version)

    return group, artifact, version


def get_timestamp():
    try:
        return execute(['date']).strip()
    except subprocess.CalledProcessError as err:
        fatal_error('could not get timestamp', cmd=err.cmd, output=err.output)


def normalize_next_version(value):
    """
    :type value: str
    :rtype:      str?
    """

    if not value:
        return None

    major, minor, patch, qualifier = parse_version(value)
    if not qualifier:
        qualifier = QUALIFIER_DEV
    return '{}.{}.{}-{}'.format(major, minor, patch, qualifier)


def parse_version(version):
    """
    :type version: str
    :rtype:        int, int, int, str
    """

    m = PATTERN_VERSION.match(version)
    if not m:
        fatal_error("cannot parse unsupported version format '{}'".format(version))

    major = int(m.group('major'))
    minor = int(m.group('minor'))
    patch = int(m.group('patch'))
    qualifier = m.group('qualifier')

    if not qualifier:
        qualifier = ''

    return major, minor, patch, qualifier


def print_blue(message, *args):
    print('[commonlib.versioning] \033[34m{}\033[0m'.format(message.format(*args)))


def print_bold(message, *args):
    print('[commonlib.versioning] \033[1m{}\033[0m'.format(message.format(*args)))


def print_dim(message, *args):
    print('[commonlib.versioning] \033[2m{}\033[0m'.format(message.format(*args)))


def print_green(message, *args):
    print('[commonlib.versioning] \033[32m{}\033[0m'.format(message.format(*args)))


def print_red(message, *args):
    print('[commonlib.versioning] \033[31m{}\033[0m'.format(message.format(*args)))


def print_yellow(message, *args):
    print('[commonlib.versioning] \033[33m{}\033[0m'.format(message.format(*args)))


def to_next_version(current_version):
    """
    :type current_version: str
    :type is_rc:           bool
    :rtype:                str
    """

    major, minor, patch, qualifier = parse_version(current_version)

    minor += 1
    return '{}.{}.{}-{}'.format(major, minor, patch, QUALIFIER_DEV)


def to_release_version(current_version, is_rc):
    """
    :type current_version: str
    :type is_rc:           bool
    :rtype:                str
    """

    major, minor, patch, qualifier = parse_version(current_version)

    if not is_rc:
        return '{}.{}.{}'.format(major, minor, patch)

    rc_number = 1
    m = PATTERN_RC.match(qualifier)
    if m:
        rc_number = int(m.group(1)) + 1

    return '{}.{}.{}-{}{}'.format(major, minor, patch, QUALIFIER_RC, rc_number)


def update_gradlefile(filename, version):
    print_dim("==> applying new version '{}'", version)

    with open(filename, 'r+') as f:
        content = f.read().lstrip()  # type: str
        f.seek(0)
        f.truncate(0)

        new_content = re.sub(r'^(version\s*=?\s*).*$', "\\1'{}'".format(version), content, count=1, flags=re.MULTILINE)

        f.write(new_content)

    # Verify that gradle picked up the change
    print_dim('==> verifying change')
    _, _, reported_version = get_artifact_info()

    if version != reported_version:
        fatal_error('failed to apply!', attempted=version, gradle_reported=reported_version)

    print_dim('==> staging file')
    try:
        execute_verbose(['git', 'add', filename])
    except subprocess.CalledProcessError as err:
        fatal_error('could not stage readme file', cmd=err.cmd, output=err.output)


def update_readme(filename, group, artifact, version):
    info_block = TEMPLATE_INFO_BLOCK.format(
        artifact=artifact,
        group=group,
        timestamp=get_timestamp(),
        version=version,
        info_block_begin=INFO_BLOCK_BEGIN,
        info_block_end=INFO_BLOCK_END,
    ).strip()

    print_dim('==> applying changes (group={}, artifact={}, version={})', group, artifact, version)

    if not os.path.exists(filename):
        print_dim("==> file '{}' not found; creating", filename)
        with open(filename, 'w') as f:
            print('# ' + artifact, file=f)

    print_dim('==> attempting to replace block')
    with open(filename, 'r+') as f:
        lines = f.read().lstrip().splitlines()
        f.seek(0)
        f.truncate(0)

        did_replace = False
        skip_line = False
        for line in lines:
            if INFO_BLOCK_END in line:
                skip_line = False
                continue

            if INFO_BLOCK_BEGIN in line:
                skip_line = True
                did_replace = True

                print(info_block, file=f)
                continue

            if skip_line:
                continue

            print(line, file=f)

        if not did_replace:
            print_dim('==> block not found; appending to file')
            print('\n' + info_block, file=f)

    print_dim('==> staging file')
    try:
        execute_verbose(['git', 'add', filename])
    except subprocess.CalledProcessError as err:
        fatal_error('could not stage readme file', cmd=err.cmd, output=err.output)


if __name__ == '__main__':
    main()
