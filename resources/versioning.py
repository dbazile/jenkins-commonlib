#!/usr/bin/env python

from __future__ import print_function

import argparse
import datetime
import re
import subprocess


DEFAULT_BRANCH      = 'master'
DEFAULT_README_FILE = 'README.md'
DEFAULT_GRADLE_FILE = 'build.gradle'

PATTERN_VERSION     = re.compile(r'^(?P<major>\d+)\.(?P<minor>\d+)\.(?P<patch>\d+)*(?:-(?P<qualifier>ALPHA|BETA|RC\d+|SNAPSHOT))?$')
PATTERN_RC          = re.compile(r'^RC(\d+)$')
QUALIFIER_RC        = 'RC'
QUALIFIER_DEV       = 'SNAPSHOT'

BLURB_BORDER_BEGIN  = '-*- autogenerated release information begin -*-'
BLURB_BORDER_END    = '-*- autogenerated release information end -*-'

TEMPLATE_TAG             = 'v{release_version}'
TEMPLATE_MESSAGE_RELEASE = '[release] release v{release_version}'
TEMPLATE_MESSAGE_DEV     = '[release] update to next dev version'

TEMPLATE_BLURB = '''
{border_begin}

|          |                                                                  |
|----------|------------------------------------------------------------------|
| Group    | {group:<64} |
| Artifact | {name:<64} |
| Version  | {release_version:<64} |
| Date     | {date:<64} |

{border_end}
'''


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--branch', default=DEFAULT_BRANCH, help='override the default branch')
    parser.add_argument('--gradle-file', default=DEFAULT_GRADLE_FILE, help='override the default gradle file')
    parser.add_argument('--readme-file', default=DEFAULT_README_FILE, help='override the default README file')
    pg = parser.add_mutually_exclusive_group()
    pg.add_argument('--next-dev-version', default='', help='override the next dev version (will be suffixed with -{} if necessary)'.format(QUALIFIER_DEV))
    pg.add_argument('--rc', action='store_true', help='enables RC semantics (adds or increments "-RCn" qualifier)')
    options = parser.parse_args()

    ensure_clean_working_copy()
    checkout_branch(options.branch)

    name, group, current_version = get_artifact_info()

    release_version = to_release_version(current_version, options.rc)

    next_dev_version = normalize_next_dev_version(options.next_dev_version)
    if not next_dev_version:
        next_dev_version = to_next_dev_version(release_version, options.rc)

    print(' Current Version: {}'.format(current_version))
    print(' Release Version: {}'.format(release_version))
    print('Next Dev Version: {}'.format(next_dev_version))
    print()

    update_readme(options.readme_file, name, group, release_version)
    update_project(options.gradle_file, release_version)
    commit_release_version(options.branch, release_version)

    print()
    update_project(options.gradle_file, next_dev_version)
    commit_next_dev_version(options.branch, next_dev_version)


def checkout_branch(branch):
    try:
        execute(['git', 'checkout', branch])
    except subprocess.CalledProcessError as err:
        error("could not check out branch '{}'".format(branch, cmd=err.cmd, output=err.output.decode()))


def commit_next_dev_version(branch, next_dev_version):
    commit_message = TEMPLATE_MESSAGE_DEV.format(next_dev_version=next_dev_version)

    print("Updating dev version '{}' on branch '{}'".format(next_dev_version, branch))
    try:
        execute(['git', 'commit', '-am', commit_message])
    except subprocess.CalledProcessError as err:
        error('could not update dev version', cmd=err.cmd, output=err.output.decode())


def commit_release_version(branch, release_version):
    commit_message = TEMPLATE_MESSAGE_RELEASE.format(release_version=release_version)

    print("Committing release to branch '{}'".format(branch))
    try:
        execute(['git', 'commit', '-am', commit_message])
    except subprocess.CalledProcessError as err:
        error('could not commit release', cmd=err.cmd, output=err.output.decode())

    tag = TEMPLATE_TAG.format(release_version=release_version)

    print("Tagging release as '{}'".format(tag))
    try:
        execute(['git', 'fetch', '--tags'])
        execute(['git', 'tag', tag])
    except subprocess.CalledProcessError as err:
        error('could not fetch/create tags', cmd=err.cmd, output=err.output.decode())


def ensure_clean_working_copy():
    try:
        modified_files = execute(['git', 'diff', '--stat'])
        if modified_files:
            error('cannot proceed with uncommitted changes')
    except subprocess.CalledProcessError as err:
        error('could not check for uncommitted changes', cmd=err.cmd, output=err.output.decode())


def error(message, **kwargs):
    print('error: {}'.format(message))

    if kwargs:
        print('---')
        for k, v in kwargs.items():
            print('{} = {}'.format(k, repr(v)))
        print('---')

    exit(1)


def execute(*args, **kwargs):
    """
    :rtype: str
    """
    return subprocess.check_output(*args, stderr=subprocess.STDOUT, **kwargs).decode()


def get_artifact_info():
    """
    :rtype: str, str, str
    """
    gradle_props = {}
    for line in execute(['gradle', 'properties', '-q']).splitlines():
        if ':' not in line:
            continue
        key, value = line.split(':', 1)
        gradle_props[key.strip()] = value.strip()

    name = gradle_props.get('name')
    if not name:
        error("gradle properties missing 'name'")

    group = gradle_props.get('group')
    if not group:
        error("gradle properties missing 'group'", group=group)

    version = gradle_props.get('version')
    if not version or version == 'unspecified':
        error("gradle properties missing 'version'", version=version)

    return name, group, version


def normalize_next_dev_version(value):
    """
    :rtype: str?
    """
    if not value:
        return None

    major, minor, patch, qualifier = parse_version(value)
    if not qualifier:
        qualifier = QUALIFIER_DEV
    return '{}.{}.{}-{}'.format(major, minor, patch, qualifier)


def parse_version(version):
    """
    :type version: str
    :rtype:        int, int, int, str
    """
    m = PATTERN_VERSION.match(version)
    if not m:
        error("cannot parse unsupported version format '{}'".format(version))

    major = int(m.group('major'))
    minor = int(m.group('minor'))
    patch = int(m.group('patch'))
    qualifier = m.group('qualifier')

    if not qualifier:
        qualifier = ''

    return major, minor, patch, qualifier


def to_next_dev_version(current_version, is_rc):
    """
    :type current_version: str
    :type is_rc: bool
    :rtype: str
    """
    major, minor, patch, qualifier = parse_version(current_version)

    if not is_rc:
        minor += 1
        return '{}.{}.{}-{}'.format(major, minor, patch, QUALIFIER_DEV)

    rc_number = 1
    m = PATTERN_RC.match(qualifier)
    if m:
        rc_number = int(m.group(1)) + 1

    return '{}.{}.{}-{}{}'.format(major, minor, patch, QUALIFIER_RC, rc_number)


def to_release_version(current_version, is_rc):
    """
    :type current_version: str
    :type is_rc: bool
    """
    major, minor, patch, qualifier = parse_version(current_version)

    if not is_rc:
        return '{}.{}.{}'.format(major, minor, patch)

    rc_number = 1
    m = PATTERN_RC.match(qualifier)
    if m:
        rc_number = int(m.group(1))

    return '{}.{}.{}-{}{}'.format(major, minor, patch, QUALIFIER_RC, rc_number)


def update_project(gradle_file, version):
    with open(gradle_file, 'r+') as f:
        content = f.read().lstrip()  # type: str

        new_content = re.sub(r'^(version\s*=?\s*).*$', "\\1'{}'".format(version), content, count=1, flags=re.MULTILINE)

        f.seek(0)
        f.truncate(0)
        f.write(new_content)


def update_readme(readme_file, name, group, release_version):
    blurb = TEMPLATE_BLURB.format(
        name=name,
        group=group,
        date=datetime.datetime.utcnow().isoformat() + 'Z',
        release_version=release_version,
        border_begin=BLURB_BORDER_BEGIN,
        border_end=BLURB_BORDER_END,
    ).strip()

    with open(readme_file, 'r+') as f:
        content = f.read().lstrip()  # type: str

        # Remove the old blurb
        new_content = re.sub(r'\n?{0}.*?{1}\n*'.format(re.escape(BLURB_BORDER_BEGIN), re.escape(BLURB_BORDER_END)), '', content, flags=re.DOTALL)

        # Add the new blurb after the first heading
        new_content = re.sub(r'^(\s*#+.*)\n?', '\\1\n\n{}\n\n'.format(blurb), new_content, count=1)

        f.seek(0)
        f.truncate(0)
        f.write(new_content)


if __name__ == '__main__':
    main()
